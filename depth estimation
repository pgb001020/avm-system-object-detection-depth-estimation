import argparse
import cv2
import numpy as np
import os
import torch
import torch.nn.functional as F
from torchvision.transforms import Compose
from tqdm import tqdm

from depth_anything.dpt import DepthAnything
from depth_anything.util.transform import Resize, NormalizeImage, PrepareForNet

# 메인 코드 블록 실행
if __name__ == '__main__':
# 커맨드라인 인자를 파싱하기 위한 argparse 설정
parser = argparse.ArgumentParser()
parser.add_argument('--img-path', type=str) # 입력 이미지 또는 이미지 디렉토리 경로
parser.add_argument('--outdir', type=str, default='./vis_depth') # 결과를 저장할 디렉토리 경로
parser.add_argument('--encoder', type=str, default='vitl', choices=['vits', 'vitb', 'vitl']) # 사용할 모델 인코더 유형 선택
# 추가 옵션: 결과 이미지만 보기, 컬러 스케일 대신 흑백 출력
parser.add_argument('--pred-only', dest='pred_only', action='store_true', help='only display the prediction')
parser.add_argument('--grayscale', dest='grayscale', action='store_true', help='do not apply colorful palette')
args = parser.parse_args()
# 이미지 처리에 사용될 여백 및 캡션 설정
margin_width = 50
caption_height = 60
# OpenCV를 사용한 텍스트 출력 설정
font = cv2.FONT_HERSHEY_SIMPLEX
font_scale = 1
font_thickness = 2
# GPU 사용 가능 확인
DEVICE = 'cuda' if torch.cuda.is_available() else 'cpu'
# Depth Anything 모델 로드 및 설정
depth_anything = DepthAnything.from_pretrained('LiheYoung/depth_anything_{}14'.format(args.encoder)).to(DEVICE).eval()
# 모델의 총 파라미터 수 출력
total_params = sum(param.numel() for param in depth_anything.parameters())
print('Total parameters: {:.2f}M'.format(total_params / 1e6))
# 이미지 전처리를 위한 변환 설정
transform = Compose([
Resize(
width=518,
height=518,
resize_target=False,
keep_aspect_ratio=True,
ensure_multiple_of=14,
resize_method='lower_bound',
image_interpolation_method=cv2.INTER_CUBIC,
),
NormalizeImage(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]),
PrepareForNet(),
])
# 입력 경로가 파일인지 디렉토리인지 확인
if os.path.isfile(args.img_path):
if args.img_path.endswith('txt'):
with open(args.img_path, 'r') as f:
filenames = f.read().splitlines()
else:
filenames = [args.img_path]
else:
filenames = os.listdir(args.img_path)
filenames = [os.path.join(args.img_path, filename) for filename in filenames if not filename.startswith('.')]
filenames.sort()
# 출력 디렉토리 생성
os.makedirs(args.outdir, exist_ok=True)
# 파일명 리스트를 순회하며 각 이미지에 대해 깊이 추정 실행
for filename in tqdm(filenames):
raw_image = cv2.imread(filename)
image = cv2.cvtColor(raw_image, cv2.COLOR_BGR2RGB) / 255.0
h, w = image.shape[:2]
image = transform({'image': image})['image']
image = torch.from_numpy(image).unsqueeze(0).to(DEVICE)
# 모델 예측 실행
with torch.no_grad():
depth = depth_anything(image)
# 예측된 깊이 맵의 크기를 원본 이미지와 동일하게 조정
depth = F.interpolate(depth[None], (h, w), mode='bilinear', align_corners=False)[0, 0]
depth = (depth - depth.min()) / (depth.max() - depth.min()) * 255.0
depth = depth.cpu().numpy().astype(np.uint8)
# 흑백 옵션 선택 시 색상 맵 적용 안 함
if args.grayscale:
depth = np.repeat(depth[..., np.newaxis], 3, axis=-1)
else:
depth = cv2.applyColorMap(depth, cv2.COLORMAP_INFERNO)
filename = os.path.basename(filename)
# 결과 이미지 저장
if args.pred_only:
cv2.imwrite(os.path.join(args.outdir, filename[:filename.rfind('.')] + '_depth.png'), depth)
else:
split_region = np.ones((raw_image.shape[0], margin_width, 3), dtype=np.uint8) * 255
combined_results = cv2.hconcat([raw_image, split_region, depth])
caption_space = np.ones((caption_height, combined_results.shape[1], 3), dtype=np.uint8) * 255
captions = ['Raw image', 'Depth Anything']
segment_width = w + margin_width
for i, caption in enumerate(captions):
text_size = cv2.getTextSize(caption, font, font_scale, font_thickness)[0]
text_x = int((segment_width * i) + (w - text_size[0]) / 2)
cv2.putText(caption_space, caption, (text_x, 40), font, font_scale, (0, 0, 0), font_thickness)
final_result = cv2.vconcat([caption_space, combined_results])
cv2.imwrite(os.path.join(args.outdir, filename[:filename.rfind('.')] + '_img_depth.png'), final_result)
